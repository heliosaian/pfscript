<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <title>libhttp_ex.mrc</title>
  <link rel="stylesheet" href="mdoc.css">
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<body class=code onload="parent.document.title=&quot;libhttp_ex.mrc&quot;">
<pre>
<a name="0">/****************************************************************************************</a>
<a name="1">* &lt;b&gt;LibHTTP Examples&lt;/b&gt;</a>
<a name="2">* &lt;p&gt;</a>
<a name="3">* Series of simple real-world tests/examples to demonstrate the use of LibHTTP.</a>
<a name="4">* &lt;p&gt;</a>
<a name="5">* &lt;code&gt;&lt;b&gt;/load -rs libhttp_examples.mrc&lt;/b&gt;&lt;/code&gt; and run &lt;code&gt;&lt;b&gt;/http_test_1&lt;/b&gt;&lt;/code&gt; through &lt;code&gt;&lt;b&gt;/http_test_8&lt;/b&gt;&lt;/code&gt;</a>
<a name="6">* &lt;p&gt;</a>
<a name="7">* All tests echo their output to status window.</a>
<a name="8">*/</a>
<a name="9"></a>
<a name="10"></a>
<a name="11"></a>
<a name="12"></a>
<a name="13"></a>
<a name="14"></a>
<a name="15"></a>
<a name="16">/****************************************************************************************</a>
<a name="17">* Example 1: Get RSS feed from slashdot and echo the headlines to status window.</a>
<a name="18">* The regex just extracts the string between &amp;lt;title&amp;gt;...&amp;lt;/title&amp;gt;.</a>
<a name="19">* @param void @return void</a>
<a name="20">*/</a>
<a name="21">alias http_test_1 {</a>
<a name="22">  echo -s ----------</a>
<a name="23">  echo -s ex1: Get RSS feed from Slashdot (http://slashdot.org/index.rss)</a>
<a name="24">  http_get SLASHDOT http://slashdot.org/index.rss</a>
<a name="25">}</a>
<a name="26"></a>
<a name="27">on *:sockread:SLASHDOT {</a>
<a name="28">  if ($sockerr) return</a>
<a name="29">  var %sockinput</a>
<a name="30">  sockread %sockinput</a>
<a name="31">  if ($regex(%sockinput,/&lt;title&gt;(.+?)&lt;\/title&gt;/))  echo -s Slashdot headline: $regml(1)</a>
<a name="32">}</a>
<a name="33"></a>
<a name="34"></a>
<a name="35"></a>
<a name="36"></a>
<a name="37">/****************************************************************************************</a>
<a name="38">* Example 2: Check www.mirc.com for latest mirc release. This could of course break at</a>
<a name="39">* any time if the site maintainers decide to change the layout. No need to complain if</a>
<a name="40">* that happens, it is just an example...</a>
<a name="41">* @param void @return void</a>
<a name="42">*/</a>
<a name="43">alias http_test_2 {</a>
<a name="44">  echo -s ----------</a>
<a name="45">  echo -s ex2: Check http://www.mirc.com/news.html for latest release info</a>
<a name="46">  http_get MIRCVER http://www.mirc.com/news.html</a>
<a name="47">}</a>
<a name="48"></a>
<a name="49">on *:sockread:MIRCVER {</a>
<a name="50">  if ($sockerr) return</a>
<a name="51">  var %sockinput</a>
<a name="52">  sockread %sockinput</a>
<a name="53">  if ($regex(%sockinput,/&lt;b&gt;mIRC (\d+(\.\d+)?).*released/i)) {</a>
<a name="54">    echo -s Latest mirc version is: $regml(1) - You are running: $version</a>
<a name="55">    sockclose $sockname</a>
<a name="56">  }</a>
<a name="57">}</a>
<a name="58"></a>
<a name="59"></a>
<a name="60"></a>
<a name="61"></a>
<a name="62">/****************************************************************************************</a>
<a name="63">* Example 3: Downloads latest servers.ini. The file is saved in your mircdir as</a>
<a name="64">* servers.ini.demo.txt (so it won't overwrite your real servers.ini). This is a static</a>
<a name="65">* file so the server knows and tells us the filesize, meaning it's possible to have a </a>
<a name="66">* progress indicator using $httpsock. For dynamic content the filesize is usually not </a>
<a name="67">* known in advance, so no way to have percentage indicator. @param void @return void</a>
<a name="68">*/</a>
<a name="69">alias http_test_3 {</a>
<a name="70">  echo -s ----------</a>
<a name="71">  echo -s ex3: Download latest servers.ini (http://www.mirc.co.uk/servers.ini)</a>
<a name="72">  .remove servers.ini.demo.txt</a>
<a name="73">  http_get SERVERSINI www.mirc.co.uk:80/servers.ini</a>
<a name="74">}</a>
<a name="75"></a>
<a name="76">on *:sockread:SERVERSINI {</a>
<a name="77">  if ($sockerr) { echo -s download failed | return }</a>
<a name="78">  sockread &amp;sockinput</a>
<a name="79">  bwrite servers.ini.demo.txt -1 &amp;sockinput</a>
<a name="80">  echo -s Downloading new servers.ini, $httpsock($sockname).percent $+ % of $bytes($httpsock($sockname).size).suf</a>
<a name="81">}</a>
<a name="82"></a>
<a name="83">on *:sockclose:SERVERSINI {</a>
<a name="84">  if ($sockerr) { echo -s download failed | return }</a>
<a name="85">  echo -s Download of servers.ini complete</a>
<a name="86">}</a>
<a name="87"></a>
<a name="88"></a>
<a name="89"></a>
<a name="90"></a>
<a name="91">/****************************************************************************************</a>
<a name="92">* Example 4: Test 3 with a twist - redirection. Instead of going directly to mirc.co.uk,</a>
<a name="93">* do "I'm feeling lucky" search on google. The search redirects to the correct</a>
<a name="94">* address, and LibHTTP automatically follows it. @param void @return void</a>
<a name="95">*/</a>
<a name="96">alias http_test_4 {</a>
<a name="97">  echo -s ----------</a>
<a name="98">  echo -s ex4: I'm feeling lucky search on google for "mirc servers.ini" </a>
<a name="99">  .remove servers.ini.demo.txt</a>
<a name="100">  http_get SERVERSINI2 http://www.google.com/search?hl=en&amp;ie=UTF-8&amp;btnI&amp;q=mirc%20servers.ini</a>
<a name="101">}</a>
<a name="102"></a>
<a name="103">on *:sockread:SERVERSINI2 {</a>
<a name="104">  if ($sockerr) { echo -s download failed | return }</a>
<a name="105">  sockread &amp;sockinput</a>
<a name="106">  bwrite servers.ini.demo.txt -1 &amp;sockinput</a>
<a name="107">  echo -s Downloading new servers.ini, $bytes($httpsock($sockname).rcvd).suf of $bytes($httpsock($sockname).size).suf</a>
<a name="108">}</a>
<a name="109"></a>
<a name="110">on *:sockclose:SERVERSINI2 {</a>
<a name="111">  if ($sockerr) { echo -s download failed | return }</a>
<a name="112">  echo -s Download of servers.ini complete</a>
<a name="113">}</a>
<a name="114"></a>
<a name="115"></a>
<a name="116"></a>
<a name="117"></a>
<a name="118">/****************************************************************************************</a>
<a name="119">* Example 5: Retrieve password protected file. The file is there "for now", some day I'll</a>
<a name="120">* remove it and this test will stop working. Also shows how to guard against making</a>
<a name="121">* duplicate requests by using $sockfree(...). @param void @return void</a>
<a name="122">*/</a>
<a name="123">alias http_test_5 {</a>
<a name="124">  echo -s ----------</a>
<a name="125">  echo -s ex5: Retrieve password protected file (http://test:test@koti.mbnet.fi/kinnunen/passworded/foo.txt)</a>
<a name="126">  if (!$sockfree(SECRET)) {</a>
<a name="127">    echo -s Can't re-request file yet, socket is in use</a>
<a name="128">  }   </a>
<a name="129">  else {</a>
<a name="130">    http_get SECRET http://test:test@koti.mbnet.fi/kinnunen/passworded/foo.txt</a>
<a name="131">  }</a>
<a name="132">}</a>
<a name="133"></a>
<a name="134">on *:sockread:SECRET: {</a>
<a name="135">  if ($sockerr) return</a>
<a name="136">  var %sockinput</a>
<a name="137">  sockread %sockinput</a>
<a name="138">  echo -s %sockinput </a>
<a name="139">}</a>
<a name="140"></a>
<a name="141"></a>
<a name="142"></a>
<a name="143"></a>
<a name="144">/****************************************************************************************</a>
<a name="145">* Example 6: Error handling, attempt to download a non-existing file. Server returns the</a>
<a name="146">* &lt;a href="http://offline.home.cern.ch/offline/web/http_error_codes.html"&gt;404 error&lt;/a&gt;.</a>
<a name="147">* @param void @return void</a>
<a name="148">*/ </a>
<a name="149">alias http_test_6 {</a>
<a name="150">  echo -s ----------</a>
<a name="151">  echo -s ex6: attempt to download non-existing file (http://www.mirc.co.uk/servers04_.ini)</a>
<a name="152">  http_get BADFILE http://www.mirc.co.uk/servers_.ini</a>
<a name="153">}</a>
<a name="154"></a>
<a name="155">; 404 is the code for "File Not Found"</a>
<a name="156">on *:signal:HttpErr_BADFILE: {</a>
<a name="157">  echo -s Error: $1-</a>
<a name="158">}</a>
<a name="159"></a>
<a name="160">; This never runs</a>
<a name="161">on *:sockread:BADFILE {</a>
<a name="162">  echo -s Sockread BADFILE</a>
<a name="163">}</a>
<a name="164"></a>
<a name="165"></a>
<a name="166"></a>
<a name="167"></a>
<a name="168">/****************************************************************************************</a>
<a name="169">* Example 7: Error handling, attempt connecting to invalid host. The error manifests</a>
<a name="170">* in a slightly different way if user has set to use a proxy. Connection to the</a>
<a name="171">* proxy is possible, but obviously the proxy can't fullfill the request so it returns</a>
<a name="172">* an error (usually code 500). @param void @return void</a>
<a name="173">*/</a>
<a name="174">alias http_test_7 {</a>
<a name="175">  echo -s ----------</a>
<a name="176">  echo -s ex7: attempt connecting to invalid host (http://www.04imrc.oc.uk/servers.ini)</a>
<a name="177">  http_get BADHOST www.imrc.oc.uk/servers.ini</a>
<a name="178">}</a>
<a name="179"></a>
<a name="180">; The error message is different if you use a proxy</a>
<a name="181">on *:signal:HttpErr_BADHOST: {</a>
<a name="182">  echo -s Error: $1-</a>
<a name="183">}</a>
<a name="184"></a>
<a name="185">; Again, this part never runs</a>
<a name="186">on *:sockread:BADHOST {</a>
<a name="187">  echo -s Sockread BADHOST</a>
<a name="188">}</a>
<a name="189"></a>
<a name="190"></a>
<a name="191"></a>
<a name="192"></a>
<a name="193">/****************************************************************************************</a>
<a name="194">* Example 8: Simple URL parsing test. The $parse_url alias used for this is an exact copy</a>
<a name="195">* of LibHTTP's URL parser, &lt;code&gt;lhttp_parse_url&lt;/code&gt;. lhttp_parse_url is a local alias</a>
<a name="196">* of LibHTTP, which is why this test cannot use it directly. @param void @return void</a>
<a name="197">*/</a>
<a name="198">alias http_test_8 {</a>
<a name="199">  echo -s ----------</a>
<a name="200">  echo -s ex8: URL parsing test</a>
<a name="201">  echo -s $parse_url(http://mircscripts.org)</a>
<a name="202">  echo -s $parse_url(http://mircscripts.org:81/)</a>
<a name="203">  echo -s $parse_url(mircscripts.org:80/)</a>
<a name="204">  echo -s $parse_url(http://admin:nimda@mircscripts.org)</a>
<a name="205">  echo -s $parse_url(admin:nimda@mircscripts.org:81/path/to/document.ext)</a>
<a name="206">  echo -s $parse_url(http://mircscripts.org/somepage.php?foo=bar&amp;bar=foo)</a>
<a name="207">}</a>
<a name="208"></a>
<a name="209"></a>
<a name="210">/****************************************************************************************</a>
<a name="211">* Needed for test_8.</a>
<a name="212">* @return String Host Port Path [Username] [Password]</a>
<a name="213">*/</a>
<a name="214">alias parse_url {</a>
<a name="215">  var %url = $1</a>
<a name="216">  var %port = 80</a>
<a name="217">  var %host = $gettok($remove(%url,http://),1,47)</a>
<a name="218">  var %path = / $+ $gettok($remove(%url,http://),2-,47)</a>
<a name="219">  if ($regex(%host,/^(.+):(.+)@(.+)$/)) {</a>
<a name="220">    var %user = $regml(1), %pass = $regml(2), %host = $regml(3)</a>
<a name="221">  }</a>
<a name="222">  if ($regex(%host,/^(.+):(\d+)$/)) {</a>
<a name="223">    var %host = $regml(1), %port = $regml(2)</a>
<a name="224">  }</a>
<a name="225">  return %host %port %path %user %pass</a>
<a name="226">}</a>
<a name="227"></a>
<a name="228"></a>
<a name="229">/**</a>
<a name="230">* Remove server_ini_demo_txt created in tests 2 &amp; 3</a>
<a name="231">*/</a>
<a name="232">on *:UNLOAD: {</a>
<a name="233">  .remove servers.ini.demo.txt</a>
<a name="234">}</a>
</pre>
</body>
